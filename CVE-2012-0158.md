https://www.sophos.com/en-us/medialibrary/PDFs/technical%20papers/CVE-2012-0158-An-Anatomy-of-a-Prolific-Exploit.PDF
estimate 2016 date
The code that CVE-2012-0158 exploits is housed within the Microsoft Windows Common Control Library. MSCOMCTL.OCX is a Dynamic Linked Library (DLL) containing common controls such as the ComboBox, and ProgressBar, among others. CVE-2012-0158 is 
concerned specifically with the ListView and TreeView ActiveX controls. Both of these controls can be exploited in Word documents and Excel spreadsheets, neither of which would appear out of place in emails between acquaintances or customers. 
The CVE-2012-0158 vulnerability affects Office 2003, 2007 and 2010, with the latter being the latest Microsoft offering at the time of the vulnerability’s disclosure. Despite alternatives to Microsoft Office making inroads recently, it is still the dominant player in the market
CVE-2012-0158 is classified as an “Arbitrary Code Execution” vulnerability. This type of vulnerability is considered one of the most severe as, if exploited, it allows the bad guys to hijack the program (in this case Microsoft Word/Excel) and force it to do its bidding.
The first few files to exploit CVE-2012-0158 were in the Office 97-2003 file format known as the Object Linking and Embedding Compound File format (OLE2 for short). This file format uses a FAT based hierarchic directory structure to declare storages and streams, of fixed sized blocks. OLE streams define all aspects of documents and spreadsheets.

![image](https://user-images.githubusercontent.com/24201238/45250878-b8afed80-b390-11e8-9d5d-d8734ea8a2cb.png)

![image](https://user-images.githubusercontent.com/24201238/45250884-c49baf80-b390-11e8-9153-9cda89e2b18f.png)

The screenshot above shows a CVE-2012-0158 exploit opened in an OLE2 visualization tool (edoc). The pane to the left shows the various streams that define the document such as the WordDocument stream responsible for most of the document’s substance. Highlighted in blue is the ObjectPool storage, the presence of which indicates that the document contains OLE objects. ActiveX OLE objects also define a series of child streams; most importantly the Contents stream.
The pane to the right details the raw bytes of the Contents stream and the groupings highlighted in red are identifiers for various ActiveX data structures made infamous by CVE-2012-0158 exploits. Highlighted in green is the malicious shellcode, disguised as data, that will be wrongly processed by Word causing the instructions (shown in the disassembler at the bottom) to be executed.

On the face of it, detecting CVE-2012-0158 would appear relatively routine. As long as your AV solution can parse OLE2 files, it’s simply a case of identifying the Contents stream, looking for the specific bytes (that identify it as a ListView/TreeView component) and then locating the proceeding shellcode. Unfortunately, it didn’t take the malware authors long to find a number of ingenious ways of concealing the presence of CVE-2012-0158.

Initial attempts at OLE2 obfuscation surfaced in early 2013 and centered on an interesting “feature” of the way Microsoft Excel encrypts worksheets. Encrypting Worksheets in the 97-2003 format not only scrambles stream contents, it also hides others entirely as can be seen in the screenshot below.

![image](https://user-images.githubusercontent.com/24201238/45250928-560b2180-b391-11e8-9dee-256828a58660.png)
This screenshot is of an encrypted Excel CVE-2012-0158 exploit, and the right hand pane shows the contents of the Workbook stream. As we can see, the encryption marker “Microsoft Base Cryptographic Provider v 1.0” informs us that this worksheet is encrypted, and more worryingly the streams tree in the left hand pane shows no sign of the ObjectPool storage. Using only the naked eye, it’s impossible to detect the presence of CVE-2012-0158 in these sorts of files. Of course, encrypting a file has the added disadvantage of requiring the victim to enter a password but, fortunately for the attacker, Excel will automatically decrypt a spreadsheet if the password is VelvetSweatshop. This is a neat trick as it hides content from other programs but not from Excel itself.

https://www.youtube.com/watch?time_continue=122&v=AteFjqiY1eQ

AV solutions are more than aware of this feature and can easily mimic the decryption behavior, so the bad guys still needed a more extendable solution if CVE-2012-0158 was to survive. The task was clear - they needed to find a way of masking those special bytes that identify the vulnerability, but this is near-on impossible in the OLE2 file format. The format stipulates that these bytes must be at set offsets, meaning moving or sandwiching data between them will almost certainly result in the
exploit failing to work correctly.

Fortunately for the bad guys, the answer to their prayers came in the form of the Rich Text Format. RTF files, as they are more commonly known, are primarily plain text and consist of a series of control codes and groups that define the content and formatting of the document.

Groups: identified by the open and close brace characters ({ and }) and are used to literally group related content together (such as META data like author name, title etc.) Control codes: identified by a backslash character (\) and either a control word or symbol. The most common control code is the RTF control code which must be in a group and at the start of every RTF file {\rtf.

![image](https://user-images.githubusercontent.com/24201238/45251048-d468c300-b393-11e8-9e05-dc82c9452c32.png)

In the text viewer we can see the RTF magic bytes ({\rtf), and the font table group (fonttbl) which lists all fonts available in the document. In this example we only use “Times New Roman”. The three lines that follow the font table group define the actual text of the document. The f0 control word, in the first and third line, dictates that all text within these groups should be displayed as “Times New Roman”. The second line goes one step further by making the word “simple” bold by preceding the \b control code.

object control code, which allows for files to be embedded within an RTF. As mentioned previously, RTF files are primarily plain text, so simply copying the raw bytes of one file into another isn’t standard because the embedded file may contain non-ASCII characters. To resolve this issue, RTF interprets each byte of the embedded file as two ASCII characters which depict its hexadecimal value.

![image](https://user-images.githubusercontent.com/24201238/45251090-74265100-b394-11e8-8bdd-e6adc9a057c4.png)
![image](https://user-images.githubusercontent.com/24201238/45251091-7688ab00-b394-11e8-8adf-7b8cf3389575.png)

As an example, let’s say we are embedding a CVE-2012-0158 exploited OLE2 file. OLE2 files are recognized by 8 signature bytes at the start of the file “D0 CF 11 E0 A1 B1 1A E1” (seen in the hex editor at the top of the diagram). When embedding the OLE2 file into an RTF file, Word takes the first byte “D0” and adds two characters to the RTF: the letter ‘d’ and the digit ‘0’. This method continues until every byte of the file is represented as ASCII hexadecimal, as can be seen at the bottom of the diagram.

Embedding files inside RTF is certainly nothing new; we’ve seen a variety of types of malware embedded inside RTF such as JAR, VBS and, more commonly, Windows executables. From a detection standpoint, any AV solution worth its muster can easily identify these object tags, reverse the process and scan the embedded file. So where’s the advantage?

When Microsoft Word saves an RTF file, the hexadecimal representation of any embedded file is written as a continuous stream of ASCII characters, split into equal length lines which are usually 252 characters long (as we saw in the previous diagram). Unfortunately, the bad guys soon discovered that Word is far from stringent about enforcing this formation and tampered with the format incessantly in order to confuse AV parsers.

Initially this was as simple as adding spaces, tabs and newlines between the different hexadecimal characters, usually aiming to mask the OLE2 magic bytes (as seen to the left of the diagram below).

![image](https://user-images.githubusercontent.com/24201238/45251123-03336900-b395-11e8-9a41-8dcc76dc6d84.png)
![image](https://user-images.githubusercontent.com/24201238/45251131-0a5a7700-b395-11e8-8196-a5ae4e2b6f0a.png)

This soon evolved into embedding groups between the recognition bytes. We can see two such examples of this in the screenshot to the right.
1. An atnauthor control code sandwiched between CF and 11
2. An empty group sandwiched between D0 and CF. The Control code \’ causes the proceeding hexadecimal characters to be translated into their ASCII value. In the case of 7B and 7D, the ASCII values are open and close brace.
More creative obfuscation techniques instead focused their attentions on disguising the presence of the ActiveX Contents stream. Most targeted were the 21433412 and 436f626a identifiers that we highlighted in OLE2 screenshot earlier. Primal examples did so with a series of docile control codes such as a series of forward and back slashes, all of which are ignored by Word.

![image](https://user-images.githubusercontent.com/24201238/45251150-63c2a600-b395-11e8-83ce-72d6f141dffb.png)
![image](https://user-images.githubusercontent.com/24201238/45251155-69b88700-b395-11e8-8e52-2f7f17a760a9.png)

Later variants housed sections of the embedded file in a group within the objdata group. The sample in the screenshot in the above diagram is one such example which also went one step further by obfuscating the data structure identifier 4366F62A with tabs and a nonsense control code.
Some exploit writers even choose to vent their anger through obfuscation techniques such as quoting internet memes in controls codes or nesting cryptic messages in groups to goad AV vendors.

![image](https://user-images.githubusercontent.com/24201238/45251179-db90d080-b395-11e8-8af7-f1d7f037575f.png)
![image](https://user-images.githubusercontent.com/24201238/45251180-ddf32a80-b395-11e8-9549-48416bbbc2d1.png)

The older the vulnerability got, the more incomprehensible the exploit variants became. This was likely due to AV solutions getting wise to the simpler tricks and led to increasingly more drastic levels of obfuscation. The sample in the screenshot below shows an extreme sample that wedges random control code groups amongst the data structure identifier 436F626A.

![image](https://user-images.githubusercontent.com/24201238/45251192-03803400-b396-11e8-983e-286a4cb55e6c.png)

One of the stealthiest obfuscation tricks surfaced around the end of 2013. As mentioned previously, RTF files are primarily plaintext ASCII but there are some exceptions to the rule, most notably the \bin control code. The binary control code, as it’s more commonly referred to, allows bytes to be declared as raw binary rather than the ASCII representation we’ve analyzed so far.

![image](https://user-images.githubusercontent.com/24201238/45251236-c5cfdb00-b396-11e8-8f53-a6b06d548bcb.png)

The structure of a binary control code is made up of two distinct parts: the length declaration and the raw content. For example, in the diagram above, we can see a \bin control code that declares 4 binary bytes. The space separates the specification from the content and the proceeding 4 bytes are the bytes to be interpreted as binary. This entire binary control code is equivalent to the ASCII representation shown to the right of the diagram.

The first CVE-2012-0158 samples to utilize this method declared the embedded OLE2 file as entirely binary, but in order to evoke the most mayhem, they soon moved to mixing and matching embedded file content between binary and ASCII.

The sample in the screenshot above is one of the more convoluted examples, as not only does it litter binary control codes amongst ASCII byte declarations, it goes one step further by obfuscating the ASCII with embedded meta data.

When processing the embedded data, in the sample above, the RTF reader takes the following steps:
1. Word identifies the \bin4 control code and interprets the next 4 bytes as raw binary. This includes a
null byte followed by the first three bytes of the OLE2 identifier (D0 CF 11).
2. Word reverts back to expecting hexadecimal ASCII characters and reads E0.
3. Word strips the keyword control code groups out, leaving us with the characters A1 B1 and 1A.
4. Word identifies another \bin4 control code and interprets the next 4 bytes as raw binary. This includes the last byte of the OLE2 identifier E1 and 3 null bytes.

These are just a handful of interesting samples that we have seen. Over the last four years there have been literally thousands of variations, suggesting that obfuscating embedded OLE2 exploited documents in RTF is very effective. The numbers only reinforce this assertion, as RTF files make up more than 80% of the sample set, suggesting it’s the go-to format when exploiting CVE-2012-0158.

Tellingly, 90% of those CVE-2012-0158 RTF samples contain some form of object obfuscation. As difficult as it is to emulate the idiosyncrasies of the RTF file format, the presence of obfuscation can actually be an excellent indicator of maliciousness. As we touched on before, most Office applications will save embedded data in equal length lines of ASCII encoded bytes, so the probability of clean files using the same techniques seems extremely unlikely. Essentially, the process of concealing their malicious content results in making themselves more conspicuous.

Some of the more surprising file types in the above chart include the PDF format, which utilized JavaScript to open an exploited RTF, and more intriguingly the MHTML file format. Also known as MIME HTML, exploits of this format first surfaced in early 2013 and were heavily linked to Chinese APT groups. This format later shot to fame in May 2015 when the now infamous VBA downloader campaigns started to embed their malicious code within them, another example of the far-reaching influence CVE-2012-0158 has had over the threat landscape.

MHTML files are similar to web pages, but instead of resources being linked to externally from the file, they are stored within the file itself. When Word documents are saved in the MHTML format, resources such as VBA code and ActiveX content are stored in an OLE2 file embedded within a multipart section of the file.

![image](https://user-images.githubusercontent.com/24201238/45251300-d6cd1c00-b397-11e8-9e53-eee2610c3bef.png)
![image](https://user-images.githubusercontent.com/24201238/45251302-dd5b9380-b397-11e8-801b-99ec72ee98f5.png)

The sample in the diagram above is a CVE-2012-0158 MHTML exploit opened in a text editor. Here we can see the “MIME-Version” header at the start of the file followed by a multipart section which declares the embedded OLE2 file encoded as Base64. If we decode the encoded data we find the standalone OLE2 file containing only a single stream: an ActiveX “Contents” stream (note the fluctuation in upper and lower case in another attempt to evade detection). Sure enough the contents of this stream reveal some byte patterns we should all be familiar with now.

As we’ve seen, the life of CVE-2012-0158 has been one of constant adaptation, and this has not been limited to its form but also its function. The obfuscation techniques we’ve analyzed certainly keep the AV industry on their toes but evading detection is no longer CVE-2012-0158’s biggest concern. The second of the four questions that define an attack for purpose still applies: What is the likelihood of the victim’s computer being compatible with the attack?

Four years is a long time in computing; Microsoft has released two versions of Office in that period, so chances are most people will have upgraded or at the very least updated by now. And herein lies the problem CVE-2012-0158 faces today; the percentage of computers still vulnerable is dwindling. The most likely victims will now be those with very poor security practices or those running older, pirated versions of Microsoft Office.

![image](https://user-images.githubusercontent.com/24201238/45251374-24965400-b399-11e8-9a8d-5a72583bec80.png)

If these statistics, acquired from a Microsoft Word Intruder [6] command and control server, are anything to go by, the number of computers still vulnerable to CVE-2012-0158 is as low as 15% in Europe and North America and less than 40% worldwide. This would go some way to explaining why we rarely see CVE-2012-0158 used in spam campaigns as, if you’re targeting randomly, there’s nearly an 85% chance the exploit will fail if the victim is in Europe.

One of the more alarming metrics in these numbers is the percentage of computers still vulnerable in Asia, Russia and the Ukraine; where the balance tilts in the attacker’s favor. If a victim is in any of these regions, the chances of a successful infection is more than 50/50. Given these numbers, it doesn’t take a genius to work out CVE-2012-1058 is a much more potent force if an attacker happens to be targeting these regions specifically.
